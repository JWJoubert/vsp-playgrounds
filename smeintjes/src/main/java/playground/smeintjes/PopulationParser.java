package playground.smeintjes;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;

import org.apache.log4j.Logger;
import org.matsim.api.core.v01.Id;
import org.matsim.api.core.v01.Scenario;
import org.matsim.api.core.v01.population.Activity;
import org.matsim.api.core.v01.population.Person;
import org.matsim.api.core.v01.population.Plan;
import org.matsim.api.core.v01.population.PlanElement;
import org.matsim.core.config.ConfigUtils;
import org.matsim.core.population.ActivityImpl;
import org.matsim.core.population.PopulationReaderMatsimV5;
import org.matsim.core.scenario.ScenarioImpl;
import org.matsim.core.scenario.ScenarioUtils;
import org.matsim.core.utils.collections.Tuple;
import org.matsim.core.utils.io.IOUtils;

import playground.southafrica.utilities.Header;

import scala.util.parsing.combinator.PackratParsers.Head;

/**
 * This class reads in multiple freight population files generated by 
 * playground.smeintjes.MultipleFreightPopulationGenerator. For each
 * population, for each plan (each vehicle has one plan which is the
 * vehicle's activity chain): count the number of activities (major and
 * minor),  get the start time of the first major activity in the plan.
 * These values are then written out to a .csv file. 
 * @author sumarie
 *
 */
public class PopulationParser {
	private final static Logger LOG =  Logger.getLogger(PopulationParser.class.toString());
	private Scenario scenario;

	/**
	 * @param inputPath path to the folder where the populations are saved. Do not
	 * 		  include the trialing "/" - it gets added automatically when creating the 
	 *        file names
	 * @param pmin the minimum number of points used when generating the complex network 
	 * 		  for these populations
	 * @param radius radius as described above
	 * @param numberOfPopulations the number of populations in this input folder
	 */
	public static void main(String[] args) {
		Header.printHeader(PopulationParser.class.toString(), args);
		String inputPath = args[0];
		int pmin = Integer.parseInt(args[1]);
		int radius = Integer.parseInt(args[2]);
		int numberPopulations = Integer.parseInt(args[3]);
		
		
		for (int i = 1; i < numberPopulations; i++) {
			PopulationParser parser = new PopulationParser();
			parser.parsePopulations(pmin, radius, i, inputPath);
		}
		Header.printFooter();

	}
	
	public PopulationParser() {
		this.scenario = ScenarioUtils.createScenario(ConfigUtils.createConfig());
//		((ScenarioImpl)scenario).createHouseholdsContainer();
	}
//	
	public void parsePopulations(int pmin, int radius, int populationNumber, String inputPath) {
		
		TreeMap<String, Tuple<Integer,ArrayList<Double>>> populationMap = new TreeMap<String, Tuple<Integer,ArrayList<Double>>>();
		String populationFile = String.format("%s/nationalFreight_%d_%d_%d.xml.gz", inputPath, pmin, radius, populationNumber);
		String outputFile = String.format("%s/nationalFreight_%d_%d_%d_startTimeAnalyser.csv", inputPath, pmin, radius, populationNumber);
		
		PopulationReaderMatsimV5 popReader = new PopulationReaderMatsimV5(this.scenario);
		popReader.parse(populationFile);
		LOG.info("Reading population " + populationNumber + " for configuration " + pmin + "_" + radius);
		
		Collection<? extends Person> personCollection = this.scenario.getPopulation().getPersons().values();
		for (int i = 0; i < 1000; i++) { //Only want the first 1000 vehicles in the population
			Person vehicle = personCollection.iterator().next(); //Will this only give me the first 10 vehicles??
//		for(Person vehicle : scenario.getPopulation().getPersons().values()){
			LOG.info("Getting info for vehicle: " + vehicle.getId());
			Plan selectedPlan = vehicle.getSelectedPlan();
			List<PlanElement> planElements = selectedPlan.getPlanElements();
			ArrayList<Double> timeArrayList = new ArrayList<Double>();
			String idString = vehicle.getId().toString();
			double endTime = 0.0;
			double totalDuration = 0.0;
			int numberActivities = 0;
			for(int j = 0; j < planElements.size(); j++){
//				LOG.info("Got activity " + j);
				PlanElement planElement = planElements.get(j);
				if(planElement instanceof Activity){
					LOG.info("Activity " + j + " is an activity.");
					
					
					ActivityImpl activity = (ActivityImpl) planElement;
					if (j == 0) {
						/*The first major activity*/
						endTime = activity.getEndTime();
						LOG.info("First major activity's end time is " + endTime);
						timeArrayList.add(endTime);						
					} else if(j < planElements.size() - 1){
						/*The minor activities*/
						double thisDuration = ((Activity) planElement).getMaximumDuration();
						totalDuration += thisDuration;
						LOG.info("Total duration is now:" + totalDuration);
						numberActivities += 1;
						LOG.info("Number of minor activities in chain so far: " + numberActivities);
						
					} else{
						/*The last major activity*/
						LOG.info("Last activity in chain reached.");
					}
				
				}
			}
			timeArrayList.add(1, totalDuration);
			LOG.info("Is timeArrayList empty? ---> " + timeArrayList.isEmpty());
			Tuple<Integer, ArrayList<Double>> populationTuple = new Tuple<Integer, ArrayList<Double>>(numberActivities, timeArrayList);
			LOG.info("Is numberActivities in populationTuple empty? ---> " + populationTuple.getFirst());
			LOG.info("Is timeArrayList in populationTuple empty? ---> " + populationTuple.getSecond());
			LOG.info("Is vehicleId empty? ---> " + idString);
			populationMap.put(idString, populationTuple);
			LOG.info("Population map: " + populationMap);
			personCollection.remove(vehicle);
		}
		writePopulationInfo(outputFile, populationMap);
	}
	
	



		
//			
//			this.scenario = ScenarioUtils.createScenario(ConfigUtils.createConfig());
			
			//TODO Make sure that I can use a field variable for scenario:
			//Shouldn't each population have its own scenario?? I think this 
			//will create one global scenario for ALL populations
//			PopulationReaderMatsimV5 pr = new PopulationReaderMatsimV5(this.scenario);
//			pr.parse(populationFile);
			
//			for (Person vehicle : scenario.getPopulation().getPersons().values()){
//				double endTime = 0.0;
//				double totalDuration = 0.0;
//				ArrayList<Double> timeArrayList = new ArrayList<Double>();
//				Tuple<Integer, ArrayList<Double>> infoTuple = new Tuple<Integer, ArrayList<Double>>(100000, timeArrayList);
//				Collection<? extends Person> vehicle = scenario.getPopulation().getPersons().values();
//				String idString = vehicle.getId().toString();
//				LOG.info("Doing analysis for vehicleID: " + idString);
//				Plan selectedPlan = vehicle.getSelectedPlan();
//				List<PlanElement> planElements = selectedPlan.getPlanElements();
//				int numberActivities = 0;
//				for(int j = 0; j < planElements.size(); j++){
//					LOG.info("Got activity " + j);
//					PlanElement planElement = planElements.get(j);
//					if(planElement instanceof Activity){
//						LOG.info("Activity " + j + " is an activity.");
//						
//						
//						ActivityImpl activity = (ActivityImpl) planElement;
//						if (j == 0) {
//							/*The first major activity*/
//							endTime = activity.getEndTime();
//							LOG.info("First major activity's end time is " + endTime);
//							timeArrayList.add(endTime);						
//						} else if(j < planElements.size() - 1){
//							/*The minor activities*/
//							double thisDuration = ((Activity) planElement).getMaximumDuration();
//							totalDuration += thisDuration;
//							LOG.info("Total duration is now:" + totalDuration);
//							numberActivities += 1;
//							LOG.info("Number of minor activities in chain so far: " + numberActivities);
//							
//						} else{
//							/*The last major activity*/
//							LOG.info("Last activity in chain reached.");
//						}
//					
//					}
//				}
//				timeArrayList.add(1, totalDuration);
//				LOG.info("Is timeArrayList empty? ---> " + timeArrayList.isEmpty());
//				Tuple<Integer, ArrayList<Double>> populationTuple = new Tuple<Integer, ArrayList<Double>>(numberActivities, timeArrayList);
//				LOG.info("Is numberActivities in populationTuple empty? ---> " + populationTuple.getFirst());
//				LOG.info("Is timeArrayList in populationTuple empty? ---> " + populationTuple.getSecond());
//				LOG.info("Is vehicleId empty? ---> " + idString);
//				populationMap.put(idString, populationTuple);
//				LOG.info("Population map: " + populationMap);
			
	
	public static void writePopulationInfo(String outputFile, Map<String, Tuple<Integer, ArrayList<Double>>> populationMap2){
		BufferedWriter bw = IOUtils.getBufferedWriter(outputFile);
		try {
			bw.write("vehicleId, numberMinorActivities, startTime, minorActivitiesDuration");
			bw.newLine();
			Set<Entry<String, Tuple<Integer, ArrayList<Double>>>> entrySet = populationMap2.entrySet();
			for (Entry<String, Tuple<Integer, ArrayList<Double>>> entry : entrySet) {
				String id = entry.getKey();
				int numberMinorActivities = entry.getValue().getFirst();
				double startTime = entry.getValue().getSecond().get(0);
				double totalDuration = entry.getValue().getSecond().get(1);
				bw.write(id);
				bw.write(",");
				bw.write(Integer.toString(numberMinorActivities));
				bw.write(",");
				bw.write(Double.toString(startTime));
				bw.write(",");
				bw.write(Double.toString(totalDuration));
				bw.newLine();
				
			}
			
		} catch (IOException e) {
			throw new RuntimeException("Could not read from BufferedWrited " + outputFile);
		} finally{
			try {
				bw.close();
			} catch (IOException e) {
				throw new RuntimeException("Could not close BufferedWriter " + outputFile);
			}
		}
	}

}
